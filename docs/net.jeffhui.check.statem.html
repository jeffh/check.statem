<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>net.jeffhui.check.statem documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Check.statem</span> <span class="project-version">1.0.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="net.jeffhui.check.statem.html"><div class="inner"><span>net.jeffhui.check.statem</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-always"><div class="inner"><span>always</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-always-fn"><div class="inner"><span>always-fn</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-catch-interpreter"><div class="inner"><span>catch-interpreter</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-catch-print-interpreter"><div class="inner"><span>catch-print-interpreter</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-check.21"><div class="inner"><span>check!</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-cmd-seq"><div class="inner"><span>cmd-seq</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-Command"><div class="inner"><span>Command</span></div></a></li><li class="depth-2 branch"><a href="net.jeffhui.check.statem.html#var-advance"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>advance</span></div></a></li><li class="depth-2 branch"><a href="net.jeffhui.check.statem.html#var-args"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>args</span></div></a></li><li class="depth-2 branch"><a href="net.jeffhui.check.statem.html#var-assume"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>assume</span></div></a></li><li class="depth-2 branch"><a href="net.jeffhui.check.statem.html#var-only-when"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>only-when</span></div></a></li><li class="depth-2"><a href="net.jeffhui.check.statem.html#var-verify"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>verify</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-defcommand"><div class="inner"><span>defcommand</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-defstatem"><div class="inner"><span>defstatem</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-list-commands"><div class="inner"><span>list-commands</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-lookup-command"><div class="inner"><span>lookup-command</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-print-failed-runs.21"><div class="inner"><span>print-failed-runs!</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-run-cmds"><div class="inner"><span>run-cmds</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-run-cmds-debug"><div class="inner"><span>run-cmds-debug</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-select-by-any"><div class="inner"><span>select-by-any</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-select-by-frequency"><div class="inner"><span>select-by-frequency</span></div></a></li><li class="depth-1"><a href="net.jeffhui.check.statem.html#var-valid-cmd-seq.3F"><div class="inner"><span>valid-cmd-seq?</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">net.jeffhui.check.statem</h1><div class="doc"><div class="markdown"><p>Facilities for testing stateful systems using state machines.</p>
<p>Allows defining specially annotated state machines that can be used as the basis for generating test verification programs to validate stateful specifications.</p>
<p>Test verification programs are defined as a sequence of transitions that conform to a state machine.</p>
<p>API OVERVIEW</p>
<p>The goal for state machine testing is to define the following:</p>
<ul>
  <li>A ‘model’ state machine (using <a href="net.jeffhui.check.statem.html#var-defstatem">defstatem</a>). The model state machine  defines the expected state machine behavior.</li>
  <li>A interpreter function (adapter between <a href="net.jeffhui.check.statem.html#var-defstatem">defstatem</a> and an  implementation). This function reads model state transitions and performs the  appropriate behavior in an implementation.</li>
</ul>
<p>The most important functions you need to understand are:</p>
<ul>
  <li><a href="net.jeffhui.check.statem.html#var-defstatem">defstatem</a> for defining state machines.</li>
  <li><a href="net.jeffhui.check.statem.html#var-cmd-seq">cmd-seq</a> for generating symbolic test programs from a state machine.</li>
  <li><a href="net.jeffhui.check.statem.html#var-run-cmds">run-cmds</a> for executing a symbolic test program against code that  needs to be verified. This is to compare the state machine  behavior to a real implementation.</li>
</ul>
<p>There are some useful helper functions that aid in building &amp; debugging  state machines:</p>
<ul>
  <li><a href="net.jeffhui.check.statem.html#var-check.21">check!</a> run some sanity checks against the state machine definition.</li>
  <li><a href="net.jeffhui.check.statem.html#var-run-cmds-debug">run-cmds-debug</a> is a verbose printout version of <a href="net.jeffhui.check.statem.html#var-run-cmds">run-cmds</a>.</li>
  <li><a href="net.jeffhui.check.statem.html#var-select-by-frequency">select-by-frequency</a>] allows you to skew how <a href="net.jeffhui.check.statem.html#var-cmd-seq">cmd-seq</a> generates commands.</li>
</ul></div></div><div class="public anchor" id="var-always"><h3>always</h3><h4 class="type">macro</h4><div class="usage"><code>(always body)</code><code>(always n body)</code></div><div class="doc"><div class="markdown"><p>Repeats a body that returns any clojure.test.check.results/Result conforming value up to n times. Returns the first failing result encountered.</p>
<p>This is useful to verify that asynchronous / concurrent behavior doesn’t cause any flakey behavior.</p>
<p><strong>Parameters:</strong></p>
<ul>
  <li><code>body</code> <strong>(expression)</strong>  The form to execute that returns a Result value (eg - <a href="net.jeffhui.check.statem.html#var-run-cmds">run-cmds</a>)</li>
  <li><code>n</code> <strong>(optional, integer, default is 10)</strong>  The number of times to repeatedly run a property to see if it failed.</li>
</ul>
<p><strong>Notes:</strong></p>
<p>Papers from the Erlang QuickCheck implementation mention <code>n=10</code> is a  ‘practically good enough’ value. Lower values of <code>n</code> risk not finding flaky  behavior, but higher values of <code>n</code> will require more executions (and take more  time to complete).</p>
<p><strong>Example:</strong></p>
<p>(always (run-cmds statem cmds interpreter))</p></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L1110">view source</a></div></div><div class="public anchor" id="var-always-fn"><h3>always-fn</h3><div class="usage"><code>(always-fn f)</code><code>(always-fn n f)</code></div><div class="doc"><div class="markdown"><p>Function form of <a href="net.jeffhui.check.statem.html#var-always">always</a> macro. See the macro for more details.</p>
<p><strong>Parameters:</strong></p>
<ul>
  <li><code>f</code> <strong>(function, 0-arity)</strong>  The function to execute that returns a Result value (eg - <a href="net.jeffhui.check.statem.html#var-run-cmds">run-cmds</a>)</li>
  <li><code>n</code> <strong>(optional, integer, default is 10)</strong>  The number of times to repeatedly run a property to see if it failed.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L1091">view source</a></div></div><div class="public anchor" id="var-catch-interpreter"><h3>catch-interpreter</h3><div class="usage"><code>(catch-interpreter interpreter)</code></div><div class="doc"><div class="markdown"><p>Wraps an interpreter function that provides try-catch error behavior that run-cmds expects.</p>
<p>Using this decorator is equivalent to passing <code>{:catch? true}</code> to <a href="net.jeffhui.check.statem.html#var-run-cmds-debug">run-cmds-debug</a>.</p></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L797">view source</a></div></div><div class="public anchor" id="var-catch-print-interpreter"><h3>catch-print-interpreter</h3><div class="usage"><code>(catch-print-interpreter interpreter)</code></div><div class="doc"><div class="markdown"><p>Like <a href="net.jeffhui.check.statem.html#var-catch-interpreter">catch-interpreter</a>, but prints to stdout</p>
<p>Using this decorator is equivalent to passing <code>{:catch? true}</code> to <a href="net.jeffhui.check.statem.html#var-run-cmds">run-cmds</a>.</p></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L815">view source</a></div></div><div class="public anchor" id="var-check.21"><h3>check!</h3><div class="usage"><code>(check! statem)</code></div><div class="doc"><div class="markdown"><p>Performs validations against state machine. Useful for sanity-checking state machine definitions before attempting to use them.</p>
<p>This will never run <code>verify</code> methods of state machine commands. But this does generate command sequences.</p></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L1148">view source</a></div></div><div class="public anchor" id="var-cmd-seq"><h3>cmd-seq</h3><div class="usage"><code>(cmd-seq statem)</code><code>(cmd-seq statem {:keys [select-generator size initial-state], :or {select-generator select-by-any}, :as options})</code></div><div class="doc"><div class="markdown"><p>A generator that produces a random sequence of commands that conform to a given state machine. Shrinking removes commands from the sequence while still conforming to the state machine.</p>
<p><strong>Parameters:</strong></p>
<ul>
  <li><code>statem</code> <strong>(required, StateMachine)</strong> The state machine that the sequence of commands must conform to.</li>
  <li><code>select-generator</code> <strong>(optional, fn[1-arg])</strong> A function that accepts a map of <code>{:command-kw command-impl}</code> and returns a generator that picks one of the command-impls.
    <p>The default implementation uses <a href="net.jeffhui.check.statem.html#var-select-by-any">select-by-any</a>, which does a fair random selection of commands.</p>
    <p>The map contains only commands that are valid given the current state of the state machine by using <code>assume</code>. Providing a custom function here can allow you to skew the probability any particular command is generated.</p>
  </li>
  <li><code>size</code> <strong>(optional, non-negative integer)</strong> The number of commands to generate for any particular program. The default relies on test.check’s natural sizing behavior (which increases the upper bound range as more tests are generated).</li>
  <li><code>initial-state</code> <strong>(optional, anything StateMachine accepts as model state)</strong> The initial state when the state machine starts. Should be the same as the one given to <a href="net.jeffhui.check.statem.html#var-run-cmds">run-cmds</a>.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code>(defn queue-interpreter [cmd run-cmd-ctx] ...)

(for-all [cmds (cmd-seq queue-statem)]
  (:pass? (run-cmds queue-statem cmds queue-interpreter)))
</code></pre>
<p>For a more thorough example, check out <a href="net.jeffhui.check.statem.html#var-run-cmds">run-cmds</a>.</p>
<p><strong>Generated Values:</strong></p>
<p><em>An opaque value to pass to <a href="net.jeffhui.check.statem.html#var-run-cmds">run-cmds</a>. The structure may change in the  SNAPSHOT versions.</em></p>
<p>Technically, returns a sequence of commands are in single-assignment  statement form:</p>
<pre><code>[
  [:set [:var 1] ...]
  [:set [:var 2] ...]
  [:set [:var 3] ...]
  ...
]
</code></pre>
<p>Where <code>[:var N]</code> is a return value from running a given statement. This is  abstract representation akin to this in Clojure:</p>
<pre><code>(do
  (def var1 ...)
  (def var2 ...)
  (def var3 ...)
  ...)
</code></pre>
<p>The data structure returned is a format that is intended:</p>
<ul>
  <li>To be somewhat human readable (since test.check prints this)</li>
  <li>To have enough information in each statement for an interpreter function to operate</li>
  <li>To be pure data to allow them to be stored as regression test cases</li>
  <li>To be fast at generating. State machine generation can be slow for large state machines.</li>
</ul>
<p>SNAPSHOT limitations:</p>
<p>The last reason is why the format should be considered opaque. It may be  useful for inspecting, but it should be considered ‘no warranty’ behavior for  depending on this result, say in a library.</p></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L677">view source</a></div></div><div class="public anchor" id="var-Command"><h3>Command</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>Command interface. NOTE: It’s recommended to use <a href="net.jeffhui.check.statem.html#var-defstatem">defstatem</a> and/or <a href="net.jeffhui.check.statem.html#var-defcommand">defcommand</a> instead of implementing this protocol directly. Advanced-usage only.</p>
<p>Command (aka - State Transition) represents an ‘action’ or transition that can be taken by a state machine. These transitions requires several bits of metadata:</p>
<ol>
  <li>When is calling this command valid?</li>
  <li>What data does this command require besides the current state?</li>
  <li>How does the state machine’s state change invoking this command?</li>
  <li>How do we validate this command’s behavior to another implementation?</li>
</ol>
<p>The following functions map to the following questions:</p>
<ul>
  <li><code>assume</code> and <code>only-when</code> answers #1, with the first being an optimization  of the latter.</li>
  <li><code>args</code> answers #2</li>
  <li><code>advance</code> answers #3</li>
  <li><code>verify</code> answers #4</li>
</ul>
<p>If you’re implementing these functions from <code>defstatem</code> is that the first two arguments (<code>_</code> and <code>model-state</code>) are assumed for brevity.</p></div></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-advance"><h3>advance</h3><div class="usage"><code>(advance _ model-state return-sym args)</code></div><div class="doc"><div class="markdown"><p>Returns next model state from the given model state and its arguments. Should be free of side effects.</p></div></div></div><div class="public anchor" id="var-args"><h3>args</h3><div class="usage"><code>(args _ model-state)</code></div><div class="doc"><div class="markdown"><p>Returns a vector generator to use as input arguments for the command and subsequent protocol functions below. The first argument of the vector must be the command’s keyword (eg - (gen/return :add)).</p>
<p>Should be free of side effects.</p></div></div></div><div class="public anchor" id="var-assume"><h3>assume</h3><div class="usage"><code>(assume _ model-state)</code></div><div class="doc"><div class="markdown"><p>Return true to indicate that this command can be executed based on the current model state. Should be free of side effects.</p></div></div></div><div class="public anchor" id="var-only-when"><h3>only-when</h3><div class="usage"><code>(only-when _ model-state args)</code></div><div class="doc"><div class="markdown"><p>Return true to indicate that this command can be executed based on the current model and generated arg data. Should be free of side effects.</p></div></div></div><div class="public anchor" id="var-verify"><h3>verify</h3><div class="usage"><code>(verify _ model-state previous-model-state args return-value)</code></div><div class="doc"><div class="markdown"><p>Asserts if the command is valid after state application. Should be free of side effects.</p></div></div></div></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L62">view source</a></div></div><div class="public anchor" id="var-defcommand"><h3>defcommand</h3><h4 class="type">macro</h4><div class="usage"><code>(defcommand table-name cmd-name [model-state this :as shared-bindings] &amp; methods)</code></div><div class="doc"><div class="markdown"><p>Provides an simplified way to define commands for the statem.</p>
<p>You probably want to use <a href="net.jeffhui.check.statem.html#var-defstatem">defstatem</a> instead of this macro directly. <a href="net.jeffhui.check.statem.html#var-defcommand">defcommand</a> allows you to structure your state machine more like multimethods.</p>
<p>Simply is sugar for <code>(alter-var-root state-machine assoc-in ... (reify Command ...))</code> to save typing and some boilerplate in the following ways:</p>
<ul>
  <li>all methods imply model-state and this via the 3rd argument</li>
  <li>args’s body will wrap <code>(gen/tuple (gen/return command-name-kw) ...)</code></li>
  <li>all methods have default implementations if not specified:
    <ul>
      <li><code>assume</code> returns <code>true</code></li>
      <li><code>only-when</code> returns <code>true</code></li>
      <li><code>advance</code> returns <code>model-state</code> it was given</li>
      <li><code>args</code> returns <code>nil</code>. AKA: <code>(gen/tuple (gen/return command-name-kw))</code></li>
      <li><code>verify</code> returns <code>true</code></li>
    </ul>
  </li>
</ul>
<p><strong>Example:</strong></p>
<pre><code>(defstatem set-statem)

(defcommand set-statem :add [mstate]
  (args [] [gen/integer])
  (advance [_ [_ value]] (conj (set mstate) value)))

(defcommand set-statem :has [mstate]
  (args [] [gen/integer])
  (verify [_ [_ value]] (contains? (mstate) value)))
</code></pre></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L311">view source</a></div></div><div class="public anchor" id="var-defstatem"><h3>defstatem</h3><h4 class="type">macro</h4><div class="usage"><code>(defstatem table-name &amp; commands)</code></div><div class="doc"><div class="markdown"><p>Declares a state machine for building test verification programs.</p>
<p>This macro provides syntactic sugar to creating a map that represents a state machine with Commands.</p>
<p>If you have a large state machine, you can break the state machine definition into several forms by using <code>defcommand</code> directly. Although, it may be more indicative of a bigger problem if your state machine has a lot of commands (since test.check may not be able to generate a large part of the state machine’s program space on any given run.)</p>
<p><strong>Example:</strong></p>
<pre><code>(defstatem queue-statem
  "A basic queue state machine"
  [mstate this]  ; -&gt; state machine's model state is available in all commands

  ;; define commands for the state machine
  (:enqueue (args [] gen/any-printable)
            (advance [return-sym [cmd-name item]] ((fnil conj []) mstate item))
            (verify [prev-mstate [cmd-name item] ret] ret))

  (:dequeue (assume [] (pos? (count mstate)))
            (advance [_ _] (subvec mstate 1))
            (verify [_ _ return-value] (= return-value (first mstate)))))
</code></pre>
<p><strong>Implied parameters:</strong></p>
<p>Implied parameters are like defrecord fields - parameters that exist in  every method body. For conciseness, this is defined once instead of having to  repeat it for every command. Otherwise state machine definitions would look like:</p>
<pre><code>;; NOTE: invalid code, do not use
(defstatem queue-statem
  (:enqueue (assume [this model-state])
            (args [this model-state])
            (only-when [this model-state cmd-data])
            (advance [this model-state ret-sym cmd-data])
            (verify [this model-state prev-mstate cmd-data return-value])))
</code></pre>
<p>Here’s the following implied parameters:</p>
<ul>
  <li><code>model-state</code> is the model state that is used for all commands.</li>
  <li><code>this</code> represents the command itself. Can be optionally elided.</li>
</ul>
<p><strong>Command Methods:</strong></p>
<ul>
  <li><code>(assume [] ...)</code>  Return true if this command can be used for a given the model state. If  you depend on generated data, use <code>only-when</code> instead. Although using this  method aids in faster program generation.
    <p>Default implementation returns true. Implementation must be free of side  effects.</p>
  </li>
  <li><code>(args [] ...)</code>  Return a vector of generators of data needed to execute this command.  Subsequent functions will receive the generated data as cmd-data. The  generated data is prefixed with the keyword of the command name.
    <p>Default implementation returns nil. Implementation must be free of side  effects.</p>
    <p>For example:</p>
    <pre><code>  (args [] [gen/int]) ;; =&gt; [:command-name 1]
</code></pre>
  </li>
  <li><code>(only-when [cmd-data] ...)</code>  Return true if this command can be used for a given model state or  generated command data.
    <p>Default implementation calls through to <code>assume</code>. Implementation must be  free of side effects.</p>
    <p>Parameters:</p>
    <ul>
      <li><code>model-state</code> is the model state that is used for all commands. See  ‘Implied parameters’ section above.</li>
      <li><code>cmd-data</code> refers to the generated command data from <code>args</code>.</li>
    </ul>
  </li>
  <li><code>(advance [ret-sym cmd-data] ...)</code>  Return the next model state from executing this command. ret-sym  represents the symbolic value of the return value of from calling  subject-under-test (but not yet realized).
    <p>Default implementation returns <code>mstate</code>. Implemetation must be free of  side effects.</p>
    <p>Parameters:</p>
    <ul>
      <li><code>model-state</code> is the model state that is used for all commands. See  ‘Implied parameters’ section above.</li>
      <li><code>ret-sym</code> a opaque value that represents a reference of the return  value. Alternatively said, this is a symbolic representation  of the subject under test’s return value. This may be useful  to reference usage of a return value for testing /  interpreter usage.</li>
      <li><code>cmd-data</code> refers to the generated command data from <code>args</code>.</li>
    </ul>
  </li>
  <li><code>(verify [prev-mstate cmd-data return-value] ...)</code>  Verifies the state machine against the subject under test. Returns true  if the subject under test returned the correct value (aka - passed an  assertion).
    <p>Default implementation returns true. Implementation must be free of side  effects.</p>
    <p>Parameters:</p>
    <ul>
      <li><code>model-state</code> is the model state that is used for all commands. See  ‘Implied parameters’ section above.</li>
      <li><code>prev-mstate</code> refers to the model state prior to advance.</li>
      <li><code>cmd-data</code> refers to the generated command data from <code>args</code>.</li>
      <li><code>return-value</code> refers to the actual value the subject under tested  returned when running.</li>
    </ul>
  </li>
</ul>
<p><strong>Notes:</strong></p>
<p>State machine definitions are entirely abstract - meaning there is no  external side effects that a production implementation may have. To perform  that comparison, use a function like <code>run-cmds</code> with some integration code.  This allows state machine definitions to be shared or reused against other  production implementations.</p>
<p>Other details of this macro:</p>
<ul>
  <li>args’s body will wrap <code>(gen/tuple (gen/return command-name-kw) ...)</code></li>
  <li>all methods have default implementations if not specified
    <ul>
      <li><code>assume</code> returns <code>true</code></li>
      <li><code>args</code> returns <code>nil</code>. AKA: <code>(gen/tuple (gen/return command-name-kw))</code></li>
      <li><code>only-when</code> returns <code>true</code></li>
      <li><code>advance</code> returns <code>model-state</code> it was given</li>
      <li><code>verify</code> returns <code>true</code></li>
    </ul>
  </li>
</ul>
<p><strong>Large State Machines:</strong></p>
<p>If you have a large state machine, it may be better to break it up into  multiple smaller ones to test. Smaller state machines allow test.check to  generate more of the possible program space within a typical test generation  (100 commands is test.checks’ default size maximum).</p>
<p>Alternatively, you can choose to generate commands with a skewed probability  of generating specific events. It’s probably not as good of a solution to  breaking up the state machine, but can provide a more focused exploration of  specific kinds of program generations.</p></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L111">view source</a></div></div><div class="public anchor" id="var-list-commands"><h3>list-commands</h3><div class="usage"><code>(list-commands statem)</code></div><div class="doc"><div class="markdown"><p>Returns a sequence of keywords indicating available command names for the state machine.</p>
<p><strong>Example:</strong></p>
<pre><code>(list-commands queue-statem)
;; =&gt; [:new :enqueue :dequeue]
</code></pre></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L279">view source</a></div></div><div class="public anchor" id="var-lookup-command"><h3>lookup-command</h3><div class="usage"><code>(lookup-command statem command-name)</code><code>(lookup-command statem command-name default-value)</code></div><div class="doc"><div class="markdown"><p>Returns a command that that matches a given interface. Throws if the command does not exist unless a default value is given.</p>
<p><strong>Example:</strong></p>
<pre><code>(lookup-command queue-statem :new)
;; =&gt; &lt;instance conforming to Command&gt;
</code></pre></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L290">view source</a></div></div><div class="public anchor" id="var-print-failed-runs.21"><h3>print-failed-runs!</h3><div class="usage"><code>(print-failed-runs! run-cmds-results)</code></div><div class="doc"><div class="markdown"><p>A helper function thar prints execution results if a run has failed. Useful to scan and see all failing tests. Returns the execution result.</p>
<p>(print-failed-runs! (run-cmd statem cmds interpreter))</p></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L975">view source</a></div></div><div class="public anchor" id="var-run-cmds"><h3>run-cmds</h3><div class="usage"><code>(run-cmds statem cmds interpreter)</code><code>(run-cmds statem cmds interpreter {:keys [initial-state catch?], :or {catch? true}})</code></div><div class="doc"><div class="markdown"><p>Executes the symbolic representation of a sequence of commands using an interpreter.</p>
<p>Returns a map about the execution result. Always returns a map with a key <code>:pass?</code> to indicate if the test program succeeded or failed.</p>
<p>Parameters:</p>
<ul>
  <li>
  <p><code>statem</code> <strong>(required, StateMachine)</strong> The state machine needed to verify behavior against.</p></li>
  <li>
  <p><code>cmds</code> <strong>(required, seq of symbolic commands)</strong> The sequence of commands to execute against the subject under test. This should be generated from <a href="net.jeffhui.check.statem.html#var-cmd-seq">cmd-seq</a>.</p></li>
  <li>
  <p><code>interpreter</code> <strong>(required, fn[2-args])</strong> The interface to interacting with the subject under test. See ‘Interpreter’ section below.</p></li>
  <li>
  <p><code>inital-state</code> <strong>(optional, anything valid for StateMachine’s model state)</strong> The initial state machine state. Should be the same as the one given to <a href="net.jeffhui.check.statem.html#var-cmd-seq">cmd-seq</a>.</p></li>
  <li>
  <p><code>catch?</code> <strong>(optional, bool)</strong> Should this runner attempt to catch exceptions? Catching exceptions allows the runner to minimize the failure, but may lose the original stacktrace. Defaults to true.</p></li>
</ul>
<p><strong>Interpreter:</strong></p>
<pre><code>:: (fn interpreter [cmd run-cmds-ctx])
  where
    cmd          :: [cmd-type &amp; generated-cmd-args]
    run-cmds-ctx :: {:keys [var-table]}
    var-table    :: {VariableSymbol value}
</code></pre>
<p>Interpreter receives every command to execute and is expected to run against  the subject under test. The return value of interpreter is the <code>return-value</code>  used in the state machine’s <code>verify</code> method.</p>
<p>This function bridges the model state machine with a concrete implementation.  Having this interpreter function also keeps the model state machines free  from directly comparing to a specific imlementation.</p>
<p><code>var-table</code> is a map of symbolic variables to concrete values. A symboli  value is in the form <code>[:var N]</code> in the command generation value:</p>
<pre><code>[[:set [:var 1] [:upload "foo"]]
 [:set [:var 2] [:result [:var 1]]]]
</code></pre>
<p>This allows the state machine and interpreter to hold/refer to stateful  references to from previous statements.</p>
<p>For the state machine side, look at <a href="net.jeffhui.check.statem.html#var-advance">advance</a> to see ret-sym,  which is the symbolic reference to the return value of the command after  execution.</p>
<p><strong>Example:</strong></p>
<pre><code>;; elided: TestQueue implementation
(defn queue-runner [cmd {:keys [varsym var-table]}]
  (case (first cmd)
    :new     (TestQueue. [] (second cmd))
    :enqueue (.enqueue ^IQueue (var-table (second cmd)) (nth cmd 2))
    :deque   (.dequeue ^IQueue (var-table (second cmd)))))

(defstatem queue-statem
  [mstate]
  (:new (assume [] (nil? mstate))
        (args [] [gen/pos-int])
        (advance [v [_ n]] {:items    []
                            :capacity n
                            :ref      v}))
  (:enqueue (assume [] (and (not (nil? mstate))
                            (&lt; (count (mstate :items)) (mstate :capacity))))
            (args [] [(gen/return (:ref mstate)) gen/int])
            (advance [v [_ _ n]] (update mstate :items conj n)))
  (:deque (assume [] (and (not (nil? mstate))
                          (pos? (count (mstate :items)))))
          (advance [_ _] (update mstate :items subvec 1))
          (args [] [(gen/return (:ref mstate))])
          (verify [_ _ r] (= r (first (:items mstate))))))

(for-all [cmds (cmd-seq queue-statem)]
         (run-cmds queue-statem cmds queue-interpreter))
</code></pre></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L852">view source</a></div></div><div class="public anchor" id="var-run-cmds-debug"><h3>run-cmds-debug</h3><div class="usage"><code>(run-cmds-debug statem cmds interpreter)</code><code>(run-cmds-debug statem cmds interpreter {:keys [initial-state mstate? return-value? catch? debug-method], :or {return-value? true, catch? true, mstate? true, debug-method :print}})</code></div><div class="doc"><div class="markdown"><p>Identical to <a href="net.jeffhui.check.statem.html#var-run-cmds">run-cmds</a>, but prints out data related to each command executed.</p>
<p>Because of the debugging instrumentation, this executes commands more slowly than <a href="net.jeffhui.check.statem.html#var-run-cmds">run-cmds</a>. This function is typically more useful if you’re diagnosing why one particular sequence of commands is failing.</p>
<p>Parameters:</p>
<ul>
  <li><code>statem</code> <strong>(required, StateMachine)</strong> The state machine needed to verify behavior against.</li>
  <li><code>cmds</code> <strong>(required, seq of symbolic commands)</strong> The sequence of commands to execute against the subject under test.</li>
  <li><code>interpreter</code> <strong>(required, fn[2-args])</strong> The interface to interacting with the subject under test. See ‘Interpreter’ section below.</li>
  <li><code>inital-state</code> <strong>(optional, anything valid for StateMachine’s model state)</strong> The initial state machine state. Should be the same as the one given to <code>cmd-seq</code>.</li>
  <li><code>mstate?</code> <strong>(optional, bool)</strong> If true, print out the model state after each command. Defaults to true.</li>
  <li><code>return-value?</code> <strong>(optional, bool)</strong> If true, print out the return value for <code>verify</code> after each command. Defaults to true.</li>
  <li><code>catch?</code> <strong>(optional, bool)</strong> Should this runner attempt to catch exceptions? Catching exceptions allows the runner to minimize the failure, but may lose the original stacktrace. Defaults to true.</li>
  <li><code>debug-method</code> <strong>(optional, keyword)</strong> How should debug information be emitted? Default is <code>:print</code> which prints to stdout. Supported methods:
    <ul>
      <li><code>:print</code> Prints data to stdout. Default value.</li>
      <li><code>:print-short</code> Prints data to stdout in compact form. Ignores <code>:mstate?</code> option.</li>
      <li><code>:inspect</code> Emits data to clojure.inspector/inspect.</li>
      <li><code>:inspect-tree</code> Emits data to clojure.inspector/inspect-tree</li>
      <li><code>:inspect-table</code> Emits data to clojure.inspector/inspect-tabl</li>
    </ul>
    <p>Note that inspect debug methods create windows per <code>run-cmds-debug</code> invocation, so using those methods inside a property may cause many windows to be created.</p>
  </li>
</ul></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L991">view source</a></div></div><div class="public anchor" id="var-select-by-any"><h3>select-by-any</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A helper that simply returns a generator that picks commands randomly.</p>
<p><strong>Note:</strong></p>
<p>Based on how cmd-seq works, this frequency is affected by the constraints  which the command can be valid as defined by the state machine.</p>
<p><strong>Example:</strong></p>
<pre><code>(cmd-seq statem {:select-generator select-by-any})
</code></pre></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L640">view source</a></div></div><div class="public anchor" id="var-select-by-frequency"><h3>select-by-frequency</h3><div class="usage"><code>(select-by-frequency cmd-kw-&gt;count)</code></div><div class="doc"><div class="markdown"><p>A helper that simply returns a generator that picks commands based on a probability map of the command keyword name to its likelihood.</p>
<p>The likelihood is determined by taking the value divided by the sum of all likelihoods.</p>
<p><strong>Note:</strong></p>
<p>Based on how cmd-seq works, this frequency is affected by the constraints  which the command can be valid as defined by the state machine.</p>
<p><strong>Example:</strong></p>
<pre><code>(cmd-seq statem {:select-generator (select-by-frequency {:new    1000
                                                         :add    100
                                                         :remove 10})})
</code></pre></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L654">view source</a></div></div><div class="public anchor" id="var-valid-cmd-seq.3F"><h3>valid-cmd-seq?</h3><div class="usage"><code>(valid-cmd-seq? statem cmds)</code><code>(valid-cmd-seq? statem cmds {:keys [initial-state]})</code></div><div class="doc"><div class="markdown"><p>Returns true if a sequence of commands conforms to a state machine’s requirements.</p>
<p><strong>Example:</strong></p>
<pre><code>;; for all of correct definitions of `queue-statem`, this should always pass
(for-all [cmds (cmd-seq queue-statem)]
        (valid-cmd-seq? queue-statem cmd))
</code></pre></div></div><div class="src-link"><a href="https://github.com/jeffh/check.statem/blob/1.0.0-SNAPSHOT/src/net/jeffhui/check/statem.clj#L766">view source</a></div></div></div></body></html>